import { Head } from 'mdx-deck';
import { CodeSurfer } from 'mdx-deck-code-surfer';
import nightOwl from "prism-react-renderer/themes/nightOwl"
import vsDark from "prism-react-renderer/themes/vsDark"
import { Image } from 'mdx-deck'
// export { condensed as theme } from 'mdx-deck/themes'
export { dark as theme } from 'mdx-deck/themes'

<Head>
    <title>
        React Presentation
    </title>
</Head>


<CodeSurfer
    theme={nightOwl}
    code="console.log('Hello world from React =D')"
    lang="javascript"
    showNumbers={false}
    dark={true}
/>

---
# JAVASCRIPT TOOLCHAIN
---
# JAVASCRIPT TOOLCHAIN
<ul>
    <li>Style linting</li>
    <li>Dependency Management </li>
    <li>Transpilation</li>
    <li>Compilation </li>
    <li>Minification and Compression </li>
    <li>Source-Mapping </li>
</ul>
---
# REACT COMPONENT LIFE CYCLES
---
<ul>
    <li>componentWillMount() </li>
    <li>componentWillReceiveProps(object nextProps)</li>
    <li>componentWillUnmount() </li>
    <li>componentWillUpdate(object nextProps, object nextState)  </li>
    <li>componentDidMount()  </li>
    <li>componentDidUpdate(object prevProps, object prevState)</li>
    <li>shouldComponentUpdate(object nextState, object nextProps) </li>
</ul>
---
# DEPRECATED IN NEW VERSIONS
<ul>
    <li>componentWillMount() </li>
    <li>componentWillReceiveProps(object nextProps)</li>
    <li>componentWillUpdate(object nextProps, object nextState)  </li>
</ul>

---
# REACT ROUTER
---
## CLIENT SIDE VS SERVER SIDE ROUTING
---
<Image src="router-1.png" size="800px" />
---
## HOW REACT WORKS?
---
<Image src="router-2.png" size="1500px" />
---
## Where I could learn more?
---
<CodeSurfer
    code={require("raw-loader!./snipets/router.snipet")} 
    lang="javascript"
    showNumbers={false}
    dark={true}
    steps={[
        { range: [0, 30], notes: "Range" },
        { lines: [1], notes: "Line" },
        { range: [4, 7], notes: "Range" },
        { lines: [3, 8], notes: "Line" },
        // { tokens: {1: [2,6]}, notes: "Tokens" },
        // { notes: "Start with this note"},
        // { lines: [6], notes: "Note for the first step" },
        // { range: [5, 9] },
        // { tokens: { 9: [3, 4, 5] }, notes: "Note for the third step" }
    ]}
/>
---
<CodeSurfer
    code={require("raw-loader!./snipets/router-2.snipet")} 
    lang="javascript"
    showNumbers={false}
    dark={true}
    steps={[
        { range: [0, 30], notes: "Range" },
        { tokens: {3: [5,6,7,8,9,10,11,12,13,14]}, notes: "Tokens" },
    ]}
/>
---
<CodeSurfer
    code={require("raw-loader!./snipets/router-3.snipet")} 
    lang="javascript"
    showNumbers={false}
    dark={true}
    steps={[
        { range: [0, 30], notes: "Range" },
        { tokens: {3: [5,6,7,8,9,10,11,12,13,14]}, notes: "Tokens" },
    ]}
/>
---
<CodeSurfer
    code={require("raw-loader!./snipets/router-4.snipet")} 
    lang="javascript"
    showNumbers={false}
    dark={true}
/>
---
# HIGH ORDER COMPONENT (HOC)
---
<CodeSurfer
    code={require("raw-loader!./snipets/hoc-1.snipet")} 
    lang="javascript"
    showNumbers={false}
    dark={true}
/>
---
<CodeSurfer
    code={require("raw-loader!./snipets/hoc-1.snipet")} 
    lang="javascript"
    showNumbers={false}
    dark={true}
/>
---
<CodeSurfer
    code={require("raw-loader!./snipets/hoc-2.snipet")} 
    lang="javascript"
    showNumbers={false}
    dark={true}
/>
---
# Much of their implementation is the same:
<ul>
    <li>On mount, add a change listener to DataSource.</li>
    <li>Inside the listener, call setState whenever the data source changes.</li>
    <li>On unmount, remove the change listener.</li>
</ul>
---
### We can write a function that creates components, like CommentList and BlogPost, that subscribe to DataSource.
---
<CodeSurfer
    code={require("raw-loader!./snipets/hoc-3.snipet")} 
    lang="javascript"
    showNumbers={false}
    dark={true}
/>
---
<CodeSurfer
    code={require("raw-loader!./snipets/hoc-4.snipet")} 
    lang="javascript"
    showNumbers={false}
    dark={true}
/>
---
### And that’s it! The wrapped component receives all the props of the container, along with a new prop, data, which it uses to render its output. The HOC isn’t concerned with how or why the data is used, and the wrapped component isn’t concerned with where the data came from.
---
# REDUX
---
# Common problems of "complex" React applications
---
## 1. Share data is not easy
---
<Image src='redux-1.png' size="1800px" />
---
## 2. The components aren’t really reusable without Redux.
---
<Image src='redux-2.png' size="1800px" />
---
# So the questions are:
### -> Where do I store my app state in a complex React app?
### -> How do I create components that are actually reusable?

The answer of this questions is to use Redux.
---
<Image src='redux-3.png' size="1800px" />
---
#'   '
#'   '
# Este es el codigo con CodeSurfer customizado con theme vsDark:

<CodeSurfer
    theme={vsDark}
    code={require("raw-loader!./snipets/1.snipet")} 
    lang="javascript"
    showNumbers={true}
    dark={true}
/>

---
```jsx
<Button />
``` 
---
<Image src='redux-1.png' size="1500px" />
